title: 算法复杂度
---
# 关于算法复杂度
## 时间复杂度
**概念**： 计算代码运行多少次（不计算系数）。  

**常见时间复杂度 Big  O Notation**：  
1、O(1): Constant Complexity 常数复杂度
2、O(logN): Logarithmic Complexity 对数复杂度
3、O(n): Linear Complexity 线性时间复杂度
4、O(n^2): N Square Complexity 平方复杂度
5、O(n^3): N Cubic Complexity 立方复杂度
6、O(2^n): Exponential Growth Complexity 指数复杂度
7、O(n!): Factorial Complexity 阶乘复杂度
<br/>

## 以斐波那契数列为例
1、斐波那契数列递归时间复杂度计算，按照通项公式F(n) = F(n - 1) + F(n - 2)计算就是 k^n。  

2、如果按照数学求和公式复杂度则为 O(1)。  

3、按照通项公式的计算，其实是生成了一颗递归树，中间有很多重复计算。但是如果用中间变量缓存和循环，就可以大大优化。  

## 各数列遍历中的时间复杂度  
1、一维数组二分查找： 在有序数列中查找值，时间复杂度为 O(logn)。  

2、二叉树遍历： O(n)

3、二维矩阵有序遍历： O(n)  

4、归并排序： O(n * logn)


## 相关面试题  
1、二叉树的前序、中序、后序时间复杂度都是O(n),n 为二叉树节点总数。因为访问二叉树时，每个节点需要访问一次，但仅访问一次。
`前序：根-左-右`
`中序：左-根-右`
`后序：左-右-根`  
2、图的便利顺序如上。  
3、深度优先、广度优先都是O(n)。  
4、二次查找的时间 O(logn)。  

## 空间复杂度的计算方法  
1、通过数组的长度 => 空间复杂度为 O(n)  
2、递归的深度
3、如果同时使用了两种，取其最大值  

# 数组、链表、跳表
1、数组（Array）进行增删操作时间复杂度是 O(n)，查、改、lookup是O(1)  
2、链表 (LinkedList) 进行增删操作时间复杂度是 O(1)，查、改是O(n)
`
链表的第一个元素叫做head,最后一个元素叫做tail，如果 tail 指向 head，则称为循环链表。
`  
3、跳表(SkipList)，插入、删除、搜索元素复杂度为 O(logN)，主要是为了取代平衡树、二分查找，是以空间换时间的一种数据结构  

4、有序一维数组结构加速方法： 升维，这样可以获取更多信息然后尽快到达目标节点

# 树
## 树和图
树是特殊的链表，图是特殊的树（图的子节点指向根节点就形成了环）。
## 树的遍历
由于树的结构，主要是通过递归，如果用广度优先遍历相对复杂。
## 二叉搜素树
二叉搜素树也称二叉排序树，排序二叉树，是指一棵空树或者具有下列性质的二叉树：  

1、左子树的所有节点的值均小于根节点的值  

2、右子树的所有节点的值均大于根节点的值  

3、以此类推，左右子树也遵循这个规则。  

`删除根节点的方法： 1、取与根节点值最接近的左子树； 2、取大于根节点的值（第一个大于根节点的右孩子，常用第二种）`


